<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · JSON.jl</title><meta name="title" content="API Reference · JSON.jl"/><meta property="og:title" content="API Reference · JSON.jl"/><meta property="twitter:title" content="API Reference · JSON.jl"/><meta name="description" content="Documentation for JSON.jl."/><meta property="og:description" content="Documentation for JSON.jl."/><meta property="twitter:description" content="Documentation for JSON.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JSON.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">JSON.jl</a></li><li><a class="tocitem" href="../migrate/">Migration guides</a></li><li><a class="tocitem" href="../reading/">JSON Reading</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li><li><a class="tocitem" href="../writing/">JSON Writing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIO/JSON.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIO/JSON.jl/blob/master/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><ul><li><a href="../#JSON.jl">JSON.jl</a></li><li><a href="../migrate/#Migration-guides">Migration guides</a></li><li class="no-marker"><ul><li><a href="../migrate/#Migration-guide-from-pre-1.0-1.0">Migration guide from pre-1.0 -&gt; 1.0</a></li><li><a href="../migrate/#Migration-guide-for-JSON3.jl">Migration guide for JSON3.jl</a></li></ul></li><li><a href="../reading/#JSON-Reading">JSON Reading</a></li><li class="no-marker"><ul><li><a href="../reading/#Core-JSON-Parsing-JSON.lazy-and-JSON.LazyValue">Core JSON Parsing - <code>JSON.lazy</code> and <code>JSON.LazyValue</code></a></li><li><a href="../reading/#JSON.parse-Untyped-materialization"><code>JSON.parse</code> - Untyped materialization</a></li><li><a href="../reading/#JSON.parse-Typed-materialization"><code>JSON.parse</code> - Typed materialization</a></li></ul></li><li><a href="#API-Reference">API Reference</a></li><li><a href="../writing/#JSON-Writing">JSON Writing</a></li><li class="no-marker"><ul><li><a href="../writing/#Core-JSON-Serialization-JSON.json">Core JSON Serialization - <code>JSON.json</code></a></li><li><a href="../writing/#Customizing-JSON-Output">Customizing JSON Output</a></li><li><a href="../writing/#Customizing-Types">Customizing Types</a></li><li><a href="../writing/#Customizing-Struct-Serialization">Customizing Struct Serialization</a></li><li><a href="../writing/#Handling-Circular-References">Handling Circular References</a></li><li><a href="../writing/#Custom-Dictionary-Key-Serialization">Custom Dictionary Key Serialization</a></li><li><a href="../writing/#Advanced-Example:-The-FrankenStruct">Advanced Example: The FrankenStruct</a></li></ul></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.JSONText" href="#JSON.JSONText"><code>JSON.JSONText</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.JSONText</code></pre><p>Wrapper around a string containing JSON data. Can be used to insert raw JSON in JSON output, like:</p><pre><code class="language-julia hljs">json(JSONText(&quot;{&quot;key&quot;: &quot;value&quot;}&quot;))</code></pre><p>This will output the JSON as-is, without escaping. Note that no check is done to ensure that the JSON is valid.</p><p>Can also be used to read &quot;raw JSON&quot; when parsing, meaning no specialized structure (JSON.Object, Vector{Any}, etc.) is created. Example:</p><pre><code class="language-julia hljs">x = JSON.parse(&quot;[1,2,3]&quot;, JSONText)
# x.value == &quot;[1,2,3]&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/JSON.jl#L51-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.LazyValue" href="#JSON.LazyValue"><code>JSON.LazyValue</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.LazyValue</code></pre><p>A lazy representation of a JSON value. The <code>LazyValue</code> type supports the &quot;selection&quot; syntax for lazily navigating the JSON value. Lazy values can be materialized via <code>JSON.parse(x)</code>, <code>JSON.parse(x, T)</code>, or <code>JSON.parse!(x, y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/lazy.jl#L125-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.isvalidjson" href="#JSON.isvalidjson"><code>JSON.isvalidjson</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.isvalidjson(json) -&gt; Bool</code></pre><p>Check if the given JSON is valid. This function will return <code>true</code> if the JSON is valid, and <code>false</code> otherwise. Inputs can be a string, a vector of bytes, or an IO stream, the same inputs as supported for <code>JSON.lazy</code> and <code>JSON.parse</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/JSON.jl#L78-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.json" href="#JSON.json"><code>JSON.json</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.json(x) -&gt; String
JSON.json(io, x)
JSON.json(file_name, x)</code></pre><p>Serialize <code>x</code> to JSON format. The 1st method takes just the object and returns a <code>String</code>. In the 2nd method, <code>io</code> is an <code>IO</code> object, and the JSON output will be written to it. For the 3rd method, <code>file_name</code> is a <code>String</code>, a file will be opened and the JSON output will be written to it.</p><p>All methods accept the following keyword arguments:</p><ul><li><p><code>omit_null::Union{Bool, Nothing}=nothing</code>: Controls whether struct fields that are undefined or are <code>nothing</code> are included in the JSON output. If <code>true</code>, only non-null fields are written. If <code>false</code>, all fields are included regardless of being undefined or <code>nothing</code>. If <code>nothing</code>, the behavior is determined by <code>JSON.omit_null(::Type{T})</code>, which is <code>false</code> by default.</p></li><li><p><code>omit_empty::Union{Bool, Nothing}=nothing</code>: Controls whether struct fields that are empty are included in the JSON output. If <code>true</code>, empty fields are excluded. If <code>false</code>, empty fields are included. If <code>nothing</code>, the behavior is determined by <code>JSON.omit_empty(::Type{T})</code>.</p></li><li><p><code>allownan::Bool=false</code>: If <code>true</code>, allow <code>Inf</code>, <code>-Inf</code>, and <code>NaN</code> in the output. If <code>false</code>, throw an error if <code>Inf</code>, <code>-Inf</code>, or <code>NaN</code> is encountered.</p></li><li><p><code>jsonlines::Bool=false</code>: If <code>true</code>, input must be array-like and the output will be written in the JSON Lines format, where each element of the array is written on a separate line (i.e. separated by a single newline character `</p></li></ul><p><code>).   If</code>false`, the output will be written in the standard JSON format.</p><ul><li><p><code>pretty::Union{Integer,Bool}=false</code>: Controls pretty printing of the JSON output. If <code>true</code>, the output will be pretty-printed with 2 spaces of indentation. If an integer, it will be used as the number of spaces of indentation. If <code>false</code> or <code>0</code>, the output will be compact. Note: Pretty printing is not supported when <code>jsonlines=true</code>.</p></li><li><p><code>inline_limit::Int=0</code>: For arrays shorter than this limit, pretty printing will be disabled (indentation set to 0).</p></li><li><p><code>ninf::String=&quot;-Infinity&quot;</code>: Custom string representation for negative infinity.</p></li><li><p><code>inf::String=&quot;Infinity&quot;</code>: Custom string representation for positive infinity.</p></li><li><p><code>nan::String=&quot;NaN&quot;</code>: Custom string representation for NaN.</p></li><li><p><code>float_style::Symbol=:shortest</code>: Controls how floating-point numbers are formatted. Options are:</p><ul><li><code>:shortest</code>: Use the shortest representation that preserves the value</li><li><code>:fixed</code>: Use fixed-point notation</li><li><code>:exp</code>: Use exponential notation</li></ul></li><li><p><code>float_precision::Int=1</code>: Number of decimal places to use when <code>float_style</code> is <code>:fixed</code> or <code>:exp</code>.</p></li><li><p><code>bufsize::Int=2^22</code>: Buffer size in bytes for IO operations. When writing to IO, the buffer will be flushed  to the IO stream once it reaches this size. This helps control memory usage during large write operations. Default is 4MB (2^22 bytes). This parameter is ignored when returning a String.</p></li><li><p><code>style::JSONStyle=JSONWriteStyle()</code>: Custom style object that controls serialization behavior. This allows customizing   certain aspects of serialization, like defining a custom <code>lower</code> method for a non-owned type. Like <code>struct MyStyle &lt;: JSONStyle end</code>,   <code>JSON.lower(x::Rational) = (num=x.num, den=x.den)</code>, then calling <code>JSON.json(1//3; style=MyStyle())</code> will output   <code>{&quot;num&quot;: 1, &quot;den&quot;: 3}</code>.</p></li></ul><p>By default, <code>x</code> must be a JSON-serializable object. Supported types include:</p><ul><li><code>AbstractString</code> =&gt; JSON string: types must support the <code>AbstractString</code> interface, specifically with support for <code>ncodeunits</code> and <code>codeunit(x, i)</code>.</li><li><code>Bool</code> =&gt; JSON boolean: must be <code>true</code> or <code>false</code></li><li><code>Nothing</code> =&gt; JSON null: must be the <code>nothing</code> singleton value</li><li><code>Number</code> =&gt; JSON number: <code>Integer</code> subtypes or <code>Union{Float16, Float32, Float64}</code> have default implementations for other <code>Number</code> types, <a href="#JSON.tostring-Tuple{Any}"><code>JSON.tostring</code></a> is first called to convert the value to a <code>String</code> before being written directly to JSON output</li><li><code>AbstractArray</code>/<code>Tuple</code>/<code>AbstractSet</code> =&gt; JSON array: objects for which <code>JSON.arraylike</code> returns <code>true</code>  are output as JSON arrays. <code>arraylike</code> is defined by default for <code>AbstractArray</code>, <code>AbstractSet</code>, <code>Tuple</code>, and <code>Base.Generator</code>. For other types that define, they must also properly implement <code>StructUtils.applyeach</code> to iterate over the index =&gt; elements pairs. Note that arrays with dimensionality &gt; 1 are written as nested arrays, with <code>N</code> nestings for <code>N</code> dimensions, and the 1st dimension is always the innermost nested JSON array (column-major order).</li><li><code>AbstractDict</code>/<code>NamedTuple</code>/structs =&gt; JSON object: if a value doesn&#39;t fall into any of the above categories, it is output as a JSON object. <code>StructUtils.applyeach</code> is called, which has appropriate implementations for <code>AbstractDict</code>, <code>NamedTuple</code>, and structs, where field names =&gt; values are iterated over. Field names can be output with an alternative name via field tag overload, like <code>field::Type &amp;(json=(name=&quot;alternative_name&quot;,),)</code></li></ul><p>If an object is not JSON-serializable, an override for <code>JSON.lower</code> can be defined to convert it to a JSON-serializable object. Some default <code>lower</code> defintions are defined in JSON itself, for example:</p><ul><li><code>StructUtils.lower(::Missing) = nothing</code></li><li><code>StructUtils.lower(x::Symbol) = String(x)</code></li><li><code>StructUtils.lower(x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType}) = string(x)</code></li><li><code>StructUtils.lower(x::Regex) = x.pattern</code></li></ul><p>These allow common Base/stdlib types to be serialized in an expected format.</p><p>Circular references are tracked automatically and cycles are broken by writing <code>null</code> for any children references.</p><p>For pre-formatted JSON data as a String, use <code>JSONText(json)</code> to write the string out as-is.</p><p>For <code>AbstractDict</code> objects with non-string keys, <code>StructUtils.lowerkey</code> will be called before serializing. This allows aggregate or other types of dict keys to be converted to an appropriate string representation. See <code>StructUtils.liftkey</code> for the reverse operation, which is called when parsing JSON data back into a dict type.</p><p><em>NOTE</em>: <code>JSON.json</code> should <em>not</em> be overloaded directly by custom types as this isn&#39;t robust for various output options (IO, String, etc.) nor recursive situations. Types should define an appropriate <code>JSON.lower</code> definition instead.</p><p>Examples:</p><pre><code class="language-julia hljs">using Dates

abstract type AbstractMonster end

struct Dracula &lt;: AbstractMonster
    num_victims::Int
end

struct Werewolf &lt;: AbstractMonster
    witching_hour::DateTime
end

struct Percent &lt;: Number
    value::Float64
end

JSON.lower(x::Percent) = x.value
StructUtils.lowerkey(x::Percent) = string(x.value)

@noarg mutable struct FrankenStruct
    id::Int
    name::String # no default to show serialization of an undefined field
    address::Union{Nothing, String} = nothing
    rate::Union{Missing, Float64} = missing
    type::Symbol = :a &amp;(json=(name=&quot;franken_type&quot;,),)
    notsure::Any = JSON.Object(&quot;key&quot; =&gt; &quot;value&quot;)
    monster::AbstractMonster = Dracula(10) &amp;(json=(lower=x -&gt; x isa Dracula ? (monster_type=&quot;vampire&quot;, num_victims=x.num_victims) : (monster_type=&quot;werewolf&quot;, witching_hour=x.witching_hour),),)
    percent::Percent = Percent(0.5)
    birthdate::Date = Date(2025, 1, 1) &amp;(json=(dateformat=&quot;yyyy/mm/dd&quot;,),)
    percentages::Dict{Percent, Int} = Dict{Percent, Int}(Percent(0.0) =&gt; 0, Percent(1.0) =&gt; 1)
    json_properties::JSONText = JSONText(&quot;{&quot;key&quot;: &quot;value&quot;}&quot;)
    matrix::Matrix{Float64} = [1.0 2.0; 3.0 4.0]
    extra_field::Any = nothing &amp;(json=(ignore=true,),)
end

franken = FrankenStruct()
franken.id = 1

json = JSON.json(franken; omit_null=false)
# &quot;{&quot;id&quot;:1,&quot;name&quot;:null,&quot;address&quot;:null,&quot;rate&quot;:null,&quot;franken_type&quot;:&quot;a&quot;,&quot;notsure&quot;:{&quot;key&quot;:&quot;value&quot;},&quot;monster&quot;:{&quot;monster_type&quot;:&quot;vampire&quot;,&quot;num_victims&quot;:10},&quot;percent&quot;:0.5,&quot;birthdate&quot;:&quot;2025/01/01&quot;,&quot;percentages&quot;:{&quot;1.0&quot;:1,&quot;0.0&quot;:0},&quot;json_properties&quot;:{&quot;key&quot;: &quot;value&quot;},&quot;matrix&quot;:[[1.0,3.0],[2.0,4.0]]}&quot;</code></pre><p>A few comments on the JSON produced in the example above:</p><ul><li>The <code>name</code> field was <code>#undef</code>, and thus was serialized as <code>null</code>.</li><li>The <code>address</code> and <code>rate</code> fields were <code>nothing</code> and <code>missing</code>, respectively, and thus were serialized as <code>null</code>.</li><li>The <code>type</code> field has a <code>name</code> field tag, so the JSON key for this field is <code>franken_type</code> instead of <code>type</code>.</li><li>The <code>notsure</code> field is a <code>JSON.Object</code>, so it is serialized as a JSON object.</li><li>The <code>monster</code> field is a <code>AbstractMonster</code>, which is a custom type. It has a <code>lower</code> field tag that specifies how the value of this field specifically (not all AbstractMonster) should be serialized</li><li>The <code>percent</code> field is a <code>Percent</code>, which is a custom type. It has a <code>lower</code> method that specifies how <code>Percent</code> values should be serialized</li><li>The <code>birthdate</code> field has a <code>dateformat</code> field tag, so the value follows the format (<code>yyyy/mm/dd</code>) instead of the default date ISO format (<code>yyyy-mm-dd</code>)</li><li>The <code>percentages</code> field is a <code>Dict{Percent, Int}</code>, which is a custom type. It has a <code>lowerkey</code> method that specifies how <code>Percent</code> keys should be serialized as strings</li><li>The <code>json_properties</code> field is a <code>JSONText</code>, so the JSONText value is serialized as-is</li><li>The <code>matrix</code> field is a <code>Matrix{Float64}</code>, which is a custom type. It is serialized as a JSON array, with the first dimension being the innermost nested JSON array (column-major order)</li><li>The <code>extra_field</code> field has a <code>ignore</code> field tag, so it is skipped when serializing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/write.jl#L214-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.lazy" href="#JSON.lazy"><code>JSON.lazy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.lazy(json; kw...)
JSON.lazyfile(file; kw...)</code></pre><p>Detect the initial JSON value in <code>json</code>, returning a <code>JSON.LazyValue</code> instance. <code>json</code> input can be:</p><ul><li><code>AbstractString</code></li><li><code>AbstractVector{UInt8}</code></li><li><code>IO</code>, <code>IOStream</code>, <code>Cmd</code> (bytes are fully read into a <code>Vector{UInt8}</code> for parsing, i.e. <code>read(json)</code> is called)</li></ul><p><code>lazyfile</code> is a convenience method that takes a filename and opens the file before calling <code>lazy</code>.</p><p>The <code>JSON.LazyValue</code> supports the &quot;selection&quot; syntax for lazily navigating the JSON value. For example (<code>x = JSON.lazy(json)</code>):</p><ul><li><code>x.key</code>, <code>x[:key]</code> or <code>x[&quot;key&quot;]</code> for JSON objects</li><li><code>x[1]</code>, <code>x[2:3]</code>, <code>x[end]</code> for JSON arrays</li><li><code>propertynames(x)</code> to see all keys in the JSON object</li><li><code>x.a.b.c</code> for selecting deeply nested values</li><li><code>x[~, (k, v) -&gt; k == &quot;foo&quot;]</code> for recursively searching for key &quot;foo&quot; and return matching values</li></ul><p>NOTE: Selecting values from a <code>LazyValue</code> will always return a <code>LazyValue</code>. Selecting a specific key of an object or index of an array will only parse what is necessary before returning. This leads to a few conclusions about how to effectively utilize <code>LazyValue</code>:</p><ul><li><code>JSON.lazy</code> is great for one-time access of a value in JSON</li><li>It&#39;s also great for finding a required deeply nested value</li><li>It&#39;s not great for any case where repeated access to values is required; this results in the same JSON being parsed on each access (i.e. naively iterating a lazy JSON array will be O(n^2))</li><li>Best practice is to use <code>JSON.lazy</code> sparingly unless there&#39;s a specific case where it will benefit; or use <code>JSON.lazy</code> as a means to access a value that is then fully materialized</li></ul><p>Another option for processing <code>JSON.LazyValue</code> is calling <code>foreach(f, x)</code> which is defined on <code>JSON.LazyValue</code> for JSON objects and arrays. For objects, <code>f</code> should be of the form <code>f(kv::Pair{String, LazyValue})</code> where <code>kv</code> is a key-value pair, and for arrays, <code>f(v::LazyValue)</code> where <code>v</code> is the value at the index. This allows for iterating over all key-value pairs in an object or all values in an array without materializing the entire structure.</p><p>Lazy values can be materialized via <code>JSON.parse</code> in a few different forms:</p><ul><li><code>JSON.parse(json)</code>: Default materialization into <code>JSON.Object</code> (a Dict-like type), <code>Vector{Any}</code>, etc.</li><li><code>JSON.parse(json, T)</code>: Materialize into a user-provided type <code>T</code> (following rules/programmatic construction from StructUtils.jl)</li><li><code>JSON.parse!(json, x)</code>: Materialize into an existing object <code>x</code> (following rules/programmatic construction from StructUtils.jl)</li></ul><p>Thus for completeness sake, here&#39;s an example of ideal usage of <code>JSON.lazy</code>:</p><pre><code class="language-julia hljs">x = JSON.lazy(very_large_json_object)
# find a deeply nested value
y = x.a.b.c.d.e.f.g
# materialize the value
z = JSON.parse(y)
# now mutate/repeatedly access values in z</code></pre><p>In this example, we only parsed as much of the <code>very_large_json_object</code> as was required to find the value <code>y</code>. Then we fully materialized <code>y</code> into <code>z</code>, which is now a normal Julia object. We can now mutate or access values in <code>z</code>.</p><p>Currently supported keyword arguments include:</p><ul><li><code>allownan::Bool = false</code>: whether &quot;special&quot; float values shoudl be allowed while parsing (<code>NaN</code>, <code>Inf</code>, <code>-Inf</code>); these values are specifically <em>not allowed</em> in the JSON spec, but many JSON libraries allow reading/writing</li><li><code>ninf::String = &quot;-Infinity&quot;</code>: the string that will be used to parse <code>-Inf</code> if <code>allownan=true</code></li><li><code>inf::String = &quot;Infinity&quot;</code>: the string that will be used to parse <code>Inf</code> if <code>allownan=true</code></li><li><code>nan::String = &quot;NaN&quot;</code>: the string that will be sued to parse <code>NaN</code> if <code>allownan=true</code></li><li><code>jsonlines::Bool = false</code>: whether the JSON input should be treated as an implicit array, with newlines separating individual JSON elements with no leading <code>&#39;[&#39;</code> or trailing <code>&#39;]&#39;</code> characters. Common in logging or streaming workflows. Defaults to <code>true</code> when used with <code>JSON.parsefile</code> and the filename extension is <code>.jsonl</code> or <code>ndjson</code>. Note this ensures that parsing will <em>always</em> return an array at the root-level.</li></ul><p>Note that validation is only fully done on <code>null</code>, <code>true</code>, and <code>false</code>, while other values are only lazily inferred from the first non-whitespace character:</p><ul><li><code>&#39;{&#39;</code>: JSON object</li><li><code>&#39;[&#39;</code>: JSON array</li><li><code>&#39;&quot;&#39;</code>: JSON string</li><li><code>&#39;0&#39;</code>-<code>&#39;9&#39;</code> or <code>&#39;-&#39;</code>: JSON number</li></ul><p>Further validation for these values is done later when materialized, like <code>JSON.parse</code>, or via selection syntax calls on a <code>LazyValue</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/lazy.jl#L1-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.lazyfile" href="#JSON.lazyfile"><code>JSON.lazyfile</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.lazy(json; kw...)
JSON.lazyfile(file; kw...)</code></pre><p>Detect the initial JSON value in <code>json</code>, returning a <code>JSON.LazyValue</code> instance. <code>json</code> input can be:</p><ul><li><code>AbstractString</code></li><li><code>AbstractVector{UInt8}</code></li><li><code>IO</code>, <code>IOStream</code>, <code>Cmd</code> (bytes are fully read into a <code>Vector{UInt8}</code> for parsing, i.e. <code>read(json)</code> is called)</li></ul><p><code>lazyfile</code> is a convenience method that takes a filename and opens the file before calling <code>lazy</code>.</p><p>The <code>JSON.LazyValue</code> supports the &quot;selection&quot; syntax for lazily navigating the JSON value. For example (<code>x = JSON.lazy(json)</code>):</p><ul><li><code>x.key</code>, <code>x[:key]</code> or <code>x[&quot;key&quot;]</code> for JSON objects</li><li><code>x[1]</code>, <code>x[2:3]</code>, <code>x[end]</code> for JSON arrays</li><li><code>propertynames(x)</code> to see all keys in the JSON object</li><li><code>x.a.b.c</code> for selecting deeply nested values</li><li><code>x[~, (k, v) -&gt; k == &quot;foo&quot;]</code> for recursively searching for key &quot;foo&quot; and return matching values</li></ul><p>NOTE: Selecting values from a <code>LazyValue</code> will always return a <code>LazyValue</code>. Selecting a specific key of an object or index of an array will only parse what is necessary before returning. This leads to a few conclusions about how to effectively utilize <code>LazyValue</code>:</p><ul><li><code>JSON.lazy</code> is great for one-time access of a value in JSON</li><li>It&#39;s also great for finding a required deeply nested value</li><li>It&#39;s not great for any case where repeated access to values is required; this results in the same JSON being parsed on each access (i.e. naively iterating a lazy JSON array will be O(n^2))</li><li>Best practice is to use <code>JSON.lazy</code> sparingly unless there&#39;s a specific case where it will benefit; or use <code>JSON.lazy</code> as a means to access a value that is then fully materialized</li></ul><p>Another option for processing <code>JSON.LazyValue</code> is calling <code>foreach(f, x)</code> which is defined on <code>JSON.LazyValue</code> for JSON objects and arrays. For objects, <code>f</code> should be of the form <code>f(kv::Pair{String, LazyValue})</code> where <code>kv</code> is a key-value pair, and for arrays, <code>f(v::LazyValue)</code> where <code>v</code> is the value at the index. This allows for iterating over all key-value pairs in an object or all values in an array without materializing the entire structure.</p><p>Lazy values can be materialized via <code>JSON.parse</code> in a few different forms:</p><ul><li><code>JSON.parse(json)</code>: Default materialization into <code>JSON.Object</code> (a Dict-like type), <code>Vector{Any}</code>, etc.</li><li><code>JSON.parse(json, T)</code>: Materialize into a user-provided type <code>T</code> (following rules/programmatic construction from StructUtils.jl)</li><li><code>JSON.parse!(json, x)</code>: Materialize into an existing object <code>x</code> (following rules/programmatic construction from StructUtils.jl)</li></ul><p>Thus for completeness sake, here&#39;s an example of ideal usage of <code>JSON.lazy</code>:</p><pre><code class="language-julia hljs">x = JSON.lazy(very_large_json_object)
# find a deeply nested value
y = x.a.b.c.d.e.f.g
# materialize the value
z = JSON.parse(y)
# now mutate/repeatedly access values in z</code></pre><p>In this example, we only parsed as much of the <code>very_large_json_object</code> as was required to find the value <code>y</code>. Then we fully materialized <code>y</code> into <code>z</code>, which is now a normal Julia object. We can now mutate or access values in <code>z</code>.</p><p>Currently supported keyword arguments include:</p><ul><li><code>allownan::Bool = false</code>: whether &quot;special&quot; float values shoudl be allowed while parsing (<code>NaN</code>, <code>Inf</code>, <code>-Inf</code>); these values are specifically <em>not allowed</em> in the JSON spec, but many JSON libraries allow reading/writing</li><li><code>ninf::String = &quot;-Infinity&quot;</code>: the string that will be used to parse <code>-Inf</code> if <code>allownan=true</code></li><li><code>inf::String = &quot;Infinity&quot;</code>: the string that will be used to parse <code>Inf</code> if <code>allownan=true</code></li><li><code>nan::String = &quot;NaN&quot;</code>: the string that will be sued to parse <code>NaN</code> if <code>allownan=true</code></li><li><code>jsonlines::Bool = false</code>: whether the JSON input should be treated as an implicit array, with newlines separating individual JSON elements with no leading <code>&#39;[&#39;</code> or trailing <code>&#39;]&#39;</code> characters. Common in logging or streaming workflows. Defaults to <code>true</code> when used with <code>JSON.parsefile</code> and the filename extension is <code>.jsonl</code> or <code>ndjson</code>. Note this ensures that parsing will <em>always</em> return an array at the root-level.</li></ul><p>Note that validation is only fully done on <code>null</code>, <code>true</code>, and <code>false</code>, while other values are only lazily inferred from the first non-whitespace character:</p><ul><li><code>&#39;{&#39;</code>: JSON object</li><li><code>&#39;[&#39;</code>: JSON array</li><li><code>&#39;&quot;&#39;</code>: JSON string</li><li><code>&#39;0&#39;</code>-<code>&#39;9&#39;</code> or <code>&#39;-&#39;</code>: JSON number</li></ul><p>Further validation for these values is done later when materialized, like <code>JSON.parse</code>, or via selection syntax calls on a <code>LazyValue</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/lazy.jl#L1-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.omit_empty-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#JSON.omit_empty-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>JSON.omit_empty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.omit_empty(::Type{T})::Bool
JSON.omit_empty(::JSONStyle, ::Type{T})::Bool</code></pre><p>Controls whether struct fields that are empty are included in the JSON output. Returns <code>false</code> by default, meaning empty fields <em>are</em> included. To instead exclude empty fields, set this to <code>true</code>. A field is considered empty if it is <code>nothing</code>, an empty collection (empty array, dict, string, tuple, or named tuple), or <code>missing</code>. This can also be controlled via the <code>omit_empty</code> keyword argument in <a href="#JSON.json"><code>JSON.json</code></a>.</p><pre><code class="language-julia hljs"># Override for a specific type
JSON.omit_empty(::Type{MyStruct}) = true

# Override for a custom style
struct MyStyle &lt;: JSON.JSONStyle end
JSON.omit_empty(::MyStyle, ::Type{T}) where {T} = true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/write.jl#L79-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.omit_null-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#JSON.omit_null-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>JSON.omit_null</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.omit_null(::Type{T})::Bool
JSON.omit_null(::JSONStyle, ::Type{T})::Bool</code></pre><p>Controls whether struct fields that are undefined or are <code>nothing</code> are included in the JSON output. Returns <code>false</code> by default, meaning all fields are included, regardless of undef or <code>nothing</code>. To instead ensure only <em>non-null</em> fields are written, set this to <code>true</code>. This can also be controlled via the <code>omit_null</code> keyword argument in <a href="#JSON.json"><code>JSON.json</code></a>.</p><pre><code class="language-julia hljs"># Override for a specific type
JSON.omit_null(::Type{MyStruct}) = true

# Override for a custom style
struct MyStyle &lt;: JSON.JSONStyle end
JSON.omit_null(::MyStyle, ::Type{T}) where {T} = true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/write.jl#L19-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.parse" href="#JSON.parse"><code>JSON.parse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.parse(json)
JSON.parse(json, T)
JSON.parse!(json, x)
JSON.parsefile(filename)
JSON.parsefile(filename, T)
JSON.parsefile!(filename, x)</code></pre><p>Parse a JSON input (string, vector, stream, LazyValue, etc.) into a Julia value. The <code>parsefile</code> variants take a filename, open the file, and pass the <code>IOStream</code> to <code>parse</code>.</p><p>Currently supported keyword arguments include:</p><ul><li><code>allownan</code>: allows parsing <code>NaN</code>, <code>Inf</code>, and <code>-Inf</code> since they are otherwise invalid JSON</li><li><code>ninf</code>: string to use for <code>-Inf</code> (default: <code>&quot;-Infinity&quot;</code>)</li><li><code>inf</code>: string to use for <code>Inf</code> (default: <code>&quot;Infinity&quot;</code>)</li><li><code>nan</code>: string to use for <code>NaN</code> (default: <code>&quot;NaN&quot;</code>)</li><li><code>jsonlines</code>: treat the <code>json</code> input as an implicit JSON array, delimited by newlines, each element being parsed from each row/line in the input</li><li><code>dicttype</code>: a custom <code>AbstractDict</code> type to use instead of <code>JSON.Object{String, Any}</code> as the default type for JSON object materialization</li><li><code>null</code>: a custom value to use for JSON null values (default: <code>nothing</code>)</li><li><code>style</code>: a custom <code>StructUtils.StructStyle</code> subtype instance to be used in calls to <code>StructUtils.make</code> and <code>StructUtils.lift</code>. This allows overriding default behaviors for non-owned types.</li></ul><p>The methods without a type specified (<code>JSON.parse(json)</code>, <code>JSON.parsefile(filename)</code>), do a generic materialization into predefined default types, including:</p><ul><li>JSON object =&gt; <code>JSON.Object{String, Any}</code> (<strong>see note below</strong>)</li><li>JSON array =&gt; <code>Vector{Any}</code></li><li>JSON string =&gt; <code>String</code></li><li>JSON number =&gt; <code>Int64</code>, <code>BigInt</code>, <code>Float64</code>, or <code>BigFloat</code></li><li>JSON true =&gt; <code>true</code></li><li>JSON false =&gt; <code>false</code></li><li>JSON null =&gt; <code>nothing</code></li></ul><p>When a type <code>T</code> is specified (<code>JSON.parse(json, T)</code>, <code>JSON.parsefile(filename, T)</code>), materialization to a value of type <code>T</code> will be attempted utilizing machinery and interfaces provided by the StructUtils.jl package, including:</p><ul><li>For JSON objects, JSON keys will be matched against field names of <code>T</code> with a value being constructed via <code>T(args...)</code></li><li>If <code>T</code> was defined with the <code>@noarg</code> macro, an empty instance will be constructed, and field values set as JSON keys match field names</li><li>If <code>T</code> had default field values defined using the <code>@defaults</code> or <code>@kwarg</code> macros (from StructUtils.jl package), those will be set in the value of <code>T</code> unless different values are parsed from the JSON</li><li>JSON keys that don&#39;t match field names in <code>T</code> will be ignored (skipped over)</li><li>If a field in <code>T</code> has a <code>name</code> fieldtag, the <code>name</code> value will be used to match JSON keys instead</li><li>If <code>T</code> or any recursive field type of <code>T</code> is abstract, an appropriate <code>JSON.@choosetype T x -&gt; ...</code> definition should exist for &quot;choosing&quot; a concrete type at runtime; default type choosing exists for <code>Union{T, Missing}</code> and <code>Union{T, Nothing}</code> where the JSON value is checked if <code>null</code>. If the <code>Any</code> type is encountered, the default materialization types will be used (<code>JSON.Object</code>, <code>Vector{Any}</code>, etc.)</li><li>For any non-JSON-standard non-aggregate (i.e. non-object, non-array) field type of <code>T</code>, a <code>JSON.lift(::Type{T}, x) = ...</code> definition can be defined for how to &quot;lift&quot; the default JSON value (String, Number, Bool, <code>nothing</code>) to the type <code>T</code>; a default lift definition exists, for example, for <code>JSON.lift(::Type{Missing}, x) = missing</code> where the standard JSON value for <code>null</code> is <code>nothing</code> and it can be &quot;lifted&quot; to <code>missing</code></li><li>For any <code>T</code> or recursive field type of <code>T</code> that is <code>AbstractDict</code>, non-string/symbol/integer keys will need to have a <code>StructUtils.liftkey(::Type{T}, x))</code> definition for how to &quot;lift&quot; the JSON string key to the key type of <code>T</code></li></ul><p>For any <code>T</code> or recursive field type of <code>T</code> that is <code>JSON.JSONText</code>, the next full raw JSON value will be preserved in the <code>JSONText</code> wrapper as-is.</p><p>For the unique case of nested JSON arrays and prior knowledge of the expected dimensionality, a target type <code>T</code> can be given as an <code>AbstractArray{T, N}</code> subtype. In this case, the JSON array data is materialized as an n-dimensional array, where: the number of JSON array nestings must match the Julia array dimensionality (<code>N</code>), nested JSON arrays at matching depths are assumed to have equal lengths, and the length of the innermost JSON array is the 1st dimension length and so on. For example, the JSON array <code>[[[1.0,2.0]]]</code> would be materialized as a 3-dimensional array of <code>Float64</code> with sizes <code>(2, 1, 1)</code>, when called like <code>JSON.parse(&quot;[[[1.0,2.0]]]&quot;, Array{Float64, 3})</code>. Note that n-dimensional Julia arrays are written to json as nested JSON arrays by default, to enable lossless re-parsing, though the dimensionality must still be provided explicitly to the call to <code>parse</code> (i.e. default parsing via <code>JSON.parse(json)</code> will result in plain nested <code>Vector{Any}</code>s returned).</p><p>Examples:</p><pre><code class="language-julia hljs">using Dates

abstract type AbstractMonster end

struct Dracula &lt;: AbstractMonster
    num_victims::Int
end

struct Werewolf &lt;: AbstractMonster
    witching_hour::DateTime
end

JSON.@choosetype AbstractMonster x -&gt; x.monster_type[] == &quot;vampire&quot; ? Dracula : Werewolf

struct Percent &lt;: Number
    value::Float64
end

JSON.lift(::Type{Percent}, x) = Percent(Float64(x))
StructUtils.liftkey(::Type{Percent}, x::String) = Percent(parse(Float64, x))

@defaults struct FrankenStruct
    id::Int = 0
    name::String = &quot;Jim&quot;
    address::Union{Nothing, String} = nothing
    rate::Union{Missing, Float64} = missing
    type::Symbol = :a &amp;(json=(name=&quot;franken_type&quot;,),)
    notsure::Any = nothing
    monster::AbstractMonster = Dracula(0)
    percent::Percent = Percent(0.0)
    birthdate::Date = Date(0) &amp;(json=(dateformat=&quot;yyyy/mm/dd&quot;,),)
    percentages::Dict{Percent, Int} = Dict{Percent, Int}()
    json_properties::JSONText = JSONText(&quot;&quot;)
    matrix::Matrix{Float64} = Matrix{Float64}(undef, 0, 0)
end

json = &quot;&quot;&quot;
{
    &quot;id&quot;: 1,
    &quot;address&quot;: &quot;123 Main St&quot;,
    &quot;rate&quot;: null,
    &quot;franken_type&quot;: &quot;b&quot;,
    &quot;notsure&quot;: {&quot;key&quot;: &quot;value&quot;},
    &quot;monster&quot;: {
        &quot;monster_type&quot;: &quot;vampire&quot;,
        &quot;num_victims&quot;: 10
    },
    &quot;percent&quot;: 0.1,
    &quot;birthdate&quot;: &quot;2023/10/01&quot;,
    &quot;percentages&quot;: {
        &quot;0.1&quot;: 1,
        &quot;0.2&quot;: 2
    },
    &quot;json_properties&quot;: {&quot;key&quot;: &quot;value&quot;},
    &quot;matrix&quot;: [[1.0, 2.0], [3.0, 4.0]],
    &quot;extra_key&quot;: &quot;extra_value&quot;
}
&quot;&quot;&quot;
JSON.parse(json, FrankenStruct)
# FrankenStruct(1, &quot;Jim&quot;, &quot;123 Main St&quot;, missing, :b, JSON.Object{String, Any}(&quot;key&quot; =&gt; &quot;value&quot;), Dracula(10), Percent(0.1), Date(&quot;2023-10-01&quot;), Dict{Percent, Int64}(Percent(0.2) =&gt; 2, Percent(0.1) =&gt; 1), JSONText(&quot;{&quot;key&quot;: &quot;value&quot;}&quot;), [1.0 3.0; 2.0 4.0])</code></pre><p>Let&#39;s walk through some notable features of the example above:</p><ul><li>The <code>name</code> field isn&#39;t present in the JSON input, so the default value of <code>&quot;Jim&quot;</code> is used.</li><li>The <code>address</code> field uses a default <code>@choosetype</code> to determine that the JSON value is not <code>null</code>, so a <code>String</code> should be parsed for the field value.</li><li>The <code>rate</code> field has a <code>null</code> JSON value, so the default <code>@choosetype</code> recognizes it should be &quot;lifted&quot; to <code>Missing</code>, which then uses a predefined <code>lift</code> definition for <code>Missing</code>.</li><li>The <code>type</code> field is a <code>Symbol</code>, and has a fieldtag <code>json=(name=&quot;franken_type&quot;,)</code> which means the JSON key <code>franken_type</code> will be used to set the field value instead of the default <code>type</code> field name. A default <code>lift</code> definition for <code>Symbol</code> is used to convert the JSON string value to a <code>Symbol</code>.</li><li>The <code>notsure</code> field is of type <code>Any</code>, so the default object type <code>JSON.Object{String, Any}</code> is used to materialize the JSON value.</li><li>The <code>monster</code> field is a polymorphic type, and the JSON value has a <code>monster_type</code> key that determines which concrete type to use. The <code>@choosetype</code> macro is used to define the logic for choosing the concrete type based on the JSON input. Note that teh <code>x</code> in <code>@choosetype</code> is a <code>LazyValue</code>, so we materialize via <code>x.monster_type[]</code> in order to compare with the string <code>&quot;vampire&quot;</code>.</li><li>The <code>percent</code> field is a custom type <code>Percent</code> and the <code>JSON.lift</code> defines how to construct a <code>Percent</code> from the JSON value, which is a <code>Float64</code> in this case.</li><li>The <code>birthdate</code> field uses a custom date format for parsing, specified in the JSON input.</li><li>The <code>percentages</code> field is a dictionary with keys of type <code>Percent</code>, which is a custom type. The <code>liftkey</code> function is defined to convert the JSON string keys to <code>Percent</code> types (parses the Float64 manually)</li><li>The <code>json_properties</code> field has a type of <code>JSONText</code>, which means the raw JSON will be preserved as a String of the <code>JSONText</code> type.</li><li>The <code>matrix</code> field is a <code>Matrix{Float64}</code>, so the JSON input array-of-arrays are materialized as such.</li><li>The <code>extra_key</code> field is not defined in the <code>FrankenStruct</code> type, so it is ignored and skipped over.</li></ul><p>NOTE: Why use <code>JSON.Object{String, Any}</code> as the default object type? It provides several benefits:</p><ul><li>Behaves as a drop-in replacement for <code>Dict{String, Any}</code>, so no loss of functionality</li><li>Performance! It&#39;s internal representation means memory savings and faster construction for small objects typical in JSON (vs <code>Dict</code>)</li><li>Insertion order is preserved, so the order of keys in the JSON input is preserved in <code>JSON.Object</code></li><li>Convenient <code>getproperty</code> (i.e. <code>obj.key</code>) syntax is supported, even for <code>Object{String,Any}</code> key types (again ideal/specialized for JSON usage)</li></ul><p><code>JSON.Object</code> internal representation uses a linked list, thus key lookups are linear time (O(n)). For <em>large</em> JSON objects, (hundreds or thousands of keys), consider using a <code>Dict{String, Any}</code> instead, like <code>JSON.parse(json; dicttype=Dict{String, Any})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/parse.jl#L1-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.parsefile" href="#JSON.parsefile"><code>JSON.parsefile</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.parse(json)
JSON.parse(json, T)
JSON.parse!(json, x)
JSON.parsefile(filename)
JSON.parsefile(filename, T)
JSON.parsefile!(filename, x)</code></pre><p>Parse a JSON input (string, vector, stream, LazyValue, etc.) into a Julia value. The <code>parsefile</code> variants take a filename, open the file, and pass the <code>IOStream</code> to <code>parse</code>.</p><p>Currently supported keyword arguments include:</p><ul><li><code>allownan</code>: allows parsing <code>NaN</code>, <code>Inf</code>, and <code>-Inf</code> since they are otherwise invalid JSON</li><li><code>ninf</code>: string to use for <code>-Inf</code> (default: <code>&quot;-Infinity&quot;</code>)</li><li><code>inf</code>: string to use for <code>Inf</code> (default: <code>&quot;Infinity&quot;</code>)</li><li><code>nan</code>: string to use for <code>NaN</code> (default: <code>&quot;NaN&quot;</code>)</li><li><code>jsonlines</code>: treat the <code>json</code> input as an implicit JSON array, delimited by newlines, each element being parsed from each row/line in the input</li><li><code>dicttype</code>: a custom <code>AbstractDict</code> type to use instead of <code>JSON.Object{String, Any}</code> as the default type for JSON object materialization</li><li><code>null</code>: a custom value to use for JSON null values (default: <code>nothing</code>)</li><li><code>style</code>: a custom <code>StructUtils.StructStyle</code> subtype instance to be used in calls to <code>StructUtils.make</code> and <code>StructUtils.lift</code>. This allows overriding default behaviors for non-owned types.</li></ul><p>The methods without a type specified (<code>JSON.parse(json)</code>, <code>JSON.parsefile(filename)</code>), do a generic materialization into predefined default types, including:</p><ul><li>JSON object =&gt; <code>JSON.Object{String, Any}</code> (<strong>see note below</strong>)</li><li>JSON array =&gt; <code>Vector{Any}</code></li><li>JSON string =&gt; <code>String</code></li><li>JSON number =&gt; <code>Int64</code>, <code>BigInt</code>, <code>Float64</code>, or <code>BigFloat</code></li><li>JSON true =&gt; <code>true</code></li><li>JSON false =&gt; <code>false</code></li><li>JSON null =&gt; <code>nothing</code></li></ul><p>When a type <code>T</code> is specified (<code>JSON.parse(json, T)</code>, <code>JSON.parsefile(filename, T)</code>), materialization to a value of type <code>T</code> will be attempted utilizing machinery and interfaces provided by the StructUtils.jl package, including:</p><ul><li>For JSON objects, JSON keys will be matched against field names of <code>T</code> with a value being constructed via <code>T(args...)</code></li><li>If <code>T</code> was defined with the <code>@noarg</code> macro, an empty instance will be constructed, and field values set as JSON keys match field names</li><li>If <code>T</code> had default field values defined using the <code>@defaults</code> or <code>@kwarg</code> macros (from StructUtils.jl package), those will be set in the value of <code>T</code> unless different values are parsed from the JSON</li><li>JSON keys that don&#39;t match field names in <code>T</code> will be ignored (skipped over)</li><li>If a field in <code>T</code> has a <code>name</code> fieldtag, the <code>name</code> value will be used to match JSON keys instead</li><li>If <code>T</code> or any recursive field type of <code>T</code> is abstract, an appropriate <code>JSON.@choosetype T x -&gt; ...</code> definition should exist for &quot;choosing&quot; a concrete type at runtime; default type choosing exists for <code>Union{T, Missing}</code> and <code>Union{T, Nothing}</code> where the JSON value is checked if <code>null</code>. If the <code>Any</code> type is encountered, the default materialization types will be used (<code>JSON.Object</code>, <code>Vector{Any}</code>, etc.)</li><li>For any non-JSON-standard non-aggregate (i.e. non-object, non-array) field type of <code>T</code>, a <code>JSON.lift(::Type{T}, x) = ...</code> definition can be defined for how to &quot;lift&quot; the default JSON value (String, Number, Bool, <code>nothing</code>) to the type <code>T</code>; a default lift definition exists, for example, for <code>JSON.lift(::Type{Missing}, x) = missing</code> where the standard JSON value for <code>null</code> is <code>nothing</code> and it can be &quot;lifted&quot; to <code>missing</code></li><li>For any <code>T</code> or recursive field type of <code>T</code> that is <code>AbstractDict</code>, non-string/symbol/integer keys will need to have a <code>StructUtils.liftkey(::Type{T}, x))</code> definition for how to &quot;lift&quot; the JSON string key to the key type of <code>T</code></li></ul><p>For any <code>T</code> or recursive field type of <code>T</code> that is <code>JSON.JSONText</code>, the next full raw JSON value will be preserved in the <code>JSONText</code> wrapper as-is.</p><p>For the unique case of nested JSON arrays and prior knowledge of the expected dimensionality, a target type <code>T</code> can be given as an <code>AbstractArray{T, N}</code> subtype. In this case, the JSON array data is materialized as an n-dimensional array, where: the number of JSON array nestings must match the Julia array dimensionality (<code>N</code>), nested JSON arrays at matching depths are assumed to have equal lengths, and the length of the innermost JSON array is the 1st dimension length and so on. For example, the JSON array <code>[[[1.0,2.0]]]</code> would be materialized as a 3-dimensional array of <code>Float64</code> with sizes <code>(2, 1, 1)</code>, when called like <code>JSON.parse(&quot;[[[1.0,2.0]]]&quot;, Array{Float64, 3})</code>. Note that n-dimensional Julia arrays are written to json as nested JSON arrays by default, to enable lossless re-parsing, though the dimensionality must still be provided explicitly to the call to <code>parse</code> (i.e. default parsing via <code>JSON.parse(json)</code> will result in plain nested <code>Vector{Any}</code>s returned).</p><p>Examples:</p><pre><code class="language-julia hljs">using Dates

abstract type AbstractMonster end

struct Dracula &lt;: AbstractMonster
    num_victims::Int
end

struct Werewolf &lt;: AbstractMonster
    witching_hour::DateTime
end

JSON.@choosetype AbstractMonster x -&gt; x.monster_type[] == &quot;vampire&quot; ? Dracula : Werewolf

struct Percent &lt;: Number
    value::Float64
end

JSON.lift(::Type{Percent}, x) = Percent(Float64(x))
StructUtils.liftkey(::Type{Percent}, x::String) = Percent(parse(Float64, x))

@defaults struct FrankenStruct
    id::Int = 0
    name::String = &quot;Jim&quot;
    address::Union{Nothing, String} = nothing
    rate::Union{Missing, Float64} = missing
    type::Symbol = :a &amp;(json=(name=&quot;franken_type&quot;,),)
    notsure::Any = nothing
    monster::AbstractMonster = Dracula(0)
    percent::Percent = Percent(0.0)
    birthdate::Date = Date(0) &amp;(json=(dateformat=&quot;yyyy/mm/dd&quot;,),)
    percentages::Dict{Percent, Int} = Dict{Percent, Int}()
    json_properties::JSONText = JSONText(&quot;&quot;)
    matrix::Matrix{Float64} = Matrix{Float64}(undef, 0, 0)
end

json = &quot;&quot;&quot;
{
    &quot;id&quot;: 1,
    &quot;address&quot;: &quot;123 Main St&quot;,
    &quot;rate&quot;: null,
    &quot;franken_type&quot;: &quot;b&quot;,
    &quot;notsure&quot;: {&quot;key&quot;: &quot;value&quot;},
    &quot;monster&quot;: {
        &quot;monster_type&quot;: &quot;vampire&quot;,
        &quot;num_victims&quot;: 10
    },
    &quot;percent&quot;: 0.1,
    &quot;birthdate&quot;: &quot;2023/10/01&quot;,
    &quot;percentages&quot;: {
        &quot;0.1&quot;: 1,
        &quot;0.2&quot;: 2
    },
    &quot;json_properties&quot;: {&quot;key&quot;: &quot;value&quot;},
    &quot;matrix&quot;: [[1.0, 2.0], [3.0, 4.0]],
    &quot;extra_key&quot;: &quot;extra_value&quot;
}
&quot;&quot;&quot;
JSON.parse(json, FrankenStruct)
# FrankenStruct(1, &quot;Jim&quot;, &quot;123 Main St&quot;, missing, :b, JSON.Object{String, Any}(&quot;key&quot; =&gt; &quot;value&quot;), Dracula(10), Percent(0.1), Date(&quot;2023-10-01&quot;), Dict{Percent, Int64}(Percent(0.2) =&gt; 2, Percent(0.1) =&gt; 1), JSONText(&quot;{&quot;key&quot;: &quot;value&quot;}&quot;), [1.0 3.0; 2.0 4.0])</code></pre><p>Let&#39;s walk through some notable features of the example above:</p><ul><li>The <code>name</code> field isn&#39;t present in the JSON input, so the default value of <code>&quot;Jim&quot;</code> is used.</li><li>The <code>address</code> field uses a default <code>@choosetype</code> to determine that the JSON value is not <code>null</code>, so a <code>String</code> should be parsed for the field value.</li><li>The <code>rate</code> field has a <code>null</code> JSON value, so the default <code>@choosetype</code> recognizes it should be &quot;lifted&quot; to <code>Missing</code>, which then uses a predefined <code>lift</code> definition for <code>Missing</code>.</li><li>The <code>type</code> field is a <code>Symbol</code>, and has a fieldtag <code>json=(name=&quot;franken_type&quot;,)</code> which means the JSON key <code>franken_type</code> will be used to set the field value instead of the default <code>type</code> field name. A default <code>lift</code> definition for <code>Symbol</code> is used to convert the JSON string value to a <code>Symbol</code>.</li><li>The <code>notsure</code> field is of type <code>Any</code>, so the default object type <code>JSON.Object{String, Any}</code> is used to materialize the JSON value.</li><li>The <code>monster</code> field is a polymorphic type, and the JSON value has a <code>monster_type</code> key that determines which concrete type to use. The <code>@choosetype</code> macro is used to define the logic for choosing the concrete type based on the JSON input. Note that teh <code>x</code> in <code>@choosetype</code> is a <code>LazyValue</code>, so we materialize via <code>x.monster_type[]</code> in order to compare with the string <code>&quot;vampire&quot;</code>.</li><li>The <code>percent</code> field is a custom type <code>Percent</code> and the <code>JSON.lift</code> defines how to construct a <code>Percent</code> from the JSON value, which is a <code>Float64</code> in this case.</li><li>The <code>birthdate</code> field uses a custom date format for parsing, specified in the JSON input.</li><li>The <code>percentages</code> field is a dictionary with keys of type <code>Percent</code>, which is a custom type. The <code>liftkey</code> function is defined to convert the JSON string keys to <code>Percent</code> types (parses the Float64 manually)</li><li>The <code>json_properties</code> field has a type of <code>JSONText</code>, which means the raw JSON will be preserved as a String of the <code>JSONText</code> type.</li><li>The <code>matrix</code> field is a <code>Matrix{Float64}</code>, so the JSON input array-of-arrays are materialized as such.</li><li>The <code>extra_key</code> field is not defined in the <code>FrankenStruct</code> type, so it is ignored and skipped over.</li></ul><p>NOTE: Why use <code>JSON.Object{String, Any}</code> as the default object type? It provides several benefits:</p><ul><li>Behaves as a drop-in replacement for <code>Dict{String, Any}</code>, so no loss of functionality</li><li>Performance! It&#39;s internal representation means memory savings and faster construction for small objects typical in JSON (vs <code>Dict</code>)</li><li>Insertion order is preserved, so the order of keys in the JSON input is preserved in <code>JSON.Object</code></li><li>Convenient <code>getproperty</code> (i.e. <code>obj.key</code>) syntax is supported, even for <code>Object{String,Any}</code> key types (again ideal/specialized for JSON usage)</li></ul><p><code>JSON.Object</code> internal representation uses a linked list, thus key lookups are linear time (O(n)). For <em>large</em> JSON objects, (hundreds or thousands of keys), consider using a <code>Dict{String, Any}</code> instead, like <code>JSON.parse(json; dicttype=Dict{String, Any})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/parse.jl#L1-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.parsefile!" href="#JSON.parsefile!"><code>JSON.parsefile!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.parse(json)
JSON.parse(json, T)
JSON.parse!(json, x)
JSON.parsefile(filename)
JSON.parsefile(filename, T)
JSON.parsefile!(filename, x)</code></pre><p>Parse a JSON input (string, vector, stream, LazyValue, etc.) into a Julia value. The <code>parsefile</code> variants take a filename, open the file, and pass the <code>IOStream</code> to <code>parse</code>.</p><p>Currently supported keyword arguments include:</p><ul><li><code>allownan</code>: allows parsing <code>NaN</code>, <code>Inf</code>, and <code>-Inf</code> since they are otherwise invalid JSON</li><li><code>ninf</code>: string to use for <code>-Inf</code> (default: <code>&quot;-Infinity&quot;</code>)</li><li><code>inf</code>: string to use for <code>Inf</code> (default: <code>&quot;Infinity&quot;</code>)</li><li><code>nan</code>: string to use for <code>NaN</code> (default: <code>&quot;NaN&quot;</code>)</li><li><code>jsonlines</code>: treat the <code>json</code> input as an implicit JSON array, delimited by newlines, each element being parsed from each row/line in the input</li><li><code>dicttype</code>: a custom <code>AbstractDict</code> type to use instead of <code>JSON.Object{String, Any}</code> as the default type for JSON object materialization</li><li><code>null</code>: a custom value to use for JSON null values (default: <code>nothing</code>)</li><li><code>style</code>: a custom <code>StructUtils.StructStyle</code> subtype instance to be used in calls to <code>StructUtils.make</code> and <code>StructUtils.lift</code>. This allows overriding default behaviors for non-owned types.</li></ul><p>The methods without a type specified (<code>JSON.parse(json)</code>, <code>JSON.parsefile(filename)</code>), do a generic materialization into predefined default types, including:</p><ul><li>JSON object =&gt; <code>JSON.Object{String, Any}</code> (<strong>see note below</strong>)</li><li>JSON array =&gt; <code>Vector{Any}</code></li><li>JSON string =&gt; <code>String</code></li><li>JSON number =&gt; <code>Int64</code>, <code>BigInt</code>, <code>Float64</code>, or <code>BigFloat</code></li><li>JSON true =&gt; <code>true</code></li><li>JSON false =&gt; <code>false</code></li><li>JSON null =&gt; <code>nothing</code></li></ul><p>When a type <code>T</code> is specified (<code>JSON.parse(json, T)</code>, <code>JSON.parsefile(filename, T)</code>), materialization to a value of type <code>T</code> will be attempted utilizing machinery and interfaces provided by the StructUtils.jl package, including:</p><ul><li>For JSON objects, JSON keys will be matched against field names of <code>T</code> with a value being constructed via <code>T(args...)</code></li><li>If <code>T</code> was defined with the <code>@noarg</code> macro, an empty instance will be constructed, and field values set as JSON keys match field names</li><li>If <code>T</code> had default field values defined using the <code>@defaults</code> or <code>@kwarg</code> macros (from StructUtils.jl package), those will be set in the value of <code>T</code> unless different values are parsed from the JSON</li><li>JSON keys that don&#39;t match field names in <code>T</code> will be ignored (skipped over)</li><li>If a field in <code>T</code> has a <code>name</code> fieldtag, the <code>name</code> value will be used to match JSON keys instead</li><li>If <code>T</code> or any recursive field type of <code>T</code> is abstract, an appropriate <code>JSON.@choosetype T x -&gt; ...</code> definition should exist for &quot;choosing&quot; a concrete type at runtime; default type choosing exists for <code>Union{T, Missing}</code> and <code>Union{T, Nothing}</code> where the JSON value is checked if <code>null</code>. If the <code>Any</code> type is encountered, the default materialization types will be used (<code>JSON.Object</code>, <code>Vector{Any}</code>, etc.)</li><li>For any non-JSON-standard non-aggregate (i.e. non-object, non-array) field type of <code>T</code>, a <code>JSON.lift(::Type{T}, x) = ...</code> definition can be defined for how to &quot;lift&quot; the default JSON value (String, Number, Bool, <code>nothing</code>) to the type <code>T</code>; a default lift definition exists, for example, for <code>JSON.lift(::Type{Missing}, x) = missing</code> where the standard JSON value for <code>null</code> is <code>nothing</code> and it can be &quot;lifted&quot; to <code>missing</code></li><li>For any <code>T</code> or recursive field type of <code>T</code> that is <code>AbstractDict</code>, non-string/symbol/integer keys will need to have a <code>StructUtils.liftkey(::Type{T}, x))</code> definition for how to &quot;lift&quot; the JSON string key to the key type of <code>T</code></li></ul><p>For any <code>T</code> or recursive field type of <code>T</code> that is <code>JSON.JSONText</code>, the next full raw JSON value will be preserved in the <code>JSONText</code> wrapper as-is.</p><p>For the unique case of nested JSON arrays and prior knowledge of the expected dimensionality, a target type <code>T</code> can be given as an <code>AbstractArray{T, N}</code> subtype. In this case, the JSON array data is materialized as an n-dimensional array, where: the number of JSON array nestings must match the Julia array dimensionality (<code>N</code>), nested JSON arrays at matching depths are assumed to have equal lengths, and the length of the innermost JSON array is the 1st dimension length and so on. For example, the JSON array <code>[[[1.0,2.0]]]</code> would be materialized as a 3-dimensional array of <code>Float64</code> with sizes <code>(2, 1, 1)</code>, when called like <code>JSON.parse(&quot;[[[1.0,2.0]]]&quot;, Array{Float64, 3})</code>. Note that n-dimensional Julia arrays are written to json as nested JSON arrays by default, to enable lossless re-parsing, though the dimensionality must still be provided explicitly to the call to <code>parse</code> (i.e. default parsing via <code>JSON.parse(json)</code> will result in plain nested <code>Vector{Any}</code>s returned).</p><p>Examples:</p><pre><code class="language-julia hljs">using Dates

abstract type AbstractMonster end

struct Dracula &lt;: AbstractMonster
    num_victims::Int
end

struct Werewolf &lt;: AbstractMonster
    witching_hour::DateTime
end

JSON.@choosetype AbstractMonster x -&gt; x.monster_type[] == &quot;vampire&quot; ? Dracula : Werewolf

struct Percent &lt;: Number
    value::Float64
end

JSON.lift(::Type{Percent}, x) = Percent(Float64(x))
StructUtils.liftkey(::Type{Percent}, x::String) = Percent(parse(Float64, x))

@defaults struct FrankenStruct
    id::Int = 0
    name::String = &quot;Jim&quot;
    address::Union{Nothing, String} = nothing
    rate::Union{Missing, Float64} = missing
    type::Symbol = :a &amp;(json=(name=&quot;franken_type&quot;,),)
    notsure::Any = nothing
    monster::AbstractMonster = Dracula(0)
    percent::Percent = Percent(0.0)
    birthdate::Date = Date(0) &amp;(json=(dateformat=&quot;yyyy/mm/dd&quot;,),)
    percentages::Dict{Percent, Int} = Dict{Percent, Int}()
    json_properties::JSONText = JSONText(&quot;&quot;)
    matrix::Matrix{Float64} = Matrix{Float64}(undef, 0, 0)
end

json = &quot;&quot;&quot;
{
    &quot;id&quot;: 1,
    &quot;address&quot;: &quot;123 Main St&quot;,
    &quot;rate&quot;: null,
    &quot;franken_type&quot;: &quot;b&quot;,
    &quot;notsure&quot;: {&quot;key&quot;: &quot;value&quot;},
    &quot;monster&quot;: {
        &quot;monster_type&quot;: &quot;vampire&quot;,
        &quot;num_victims&quot;: 10
    },
    &quot;percent&quot;: 0.1,
    &quot;birthdate&quot;: &quot;2023/10/01&quot;,
    &quot;percentages&quot;: {
        &quot;0.1&quot;: 1,
        &quot;0.2&quot;: 2
    },
    &quot;json_properties&quot;: {&quot;key&quot;: &quot;value&quot;},
    &quot;matrix&quot;: [[1.0, 2.0], [3.0, 4.0]],
    &quot;extra_key&quot;: &quot;extra_value&quot;
}
&quot;&quot;&quot;
JSON.parse(json, FrankenStruct)
# FrankenStruct(1, &quot;Jim&quot;, &quot;123 Main St&quot;, missing, :b, JSON.Object{String, Any}(&quot;key&quot; =&gt; &quot;value&quot;), Dracula(10), Percent(0.1), Date(&quot;2023-10-01&quot;), Dict{Percent, Int64}(Percent(0.2) =&gt; 2, Percent(0.1) =&gt; 1), JSONText(&quot;{&quot;key&quot;: &quot;value&quot;}&quot;), [1.0 3.0; 2.0 4.0])</code></pre><p>Let&#39;s walk through some notable features of the example above:</p><ul><li>The <code>name</code> field isn&#39;t present in the JSON input, so the default value of <code>&quot;Jim&quot;</code> is used.</li><li>The <code>address</code> field uses a default <code>@choosetype</code> to determine that the JSON value is not <code>null</code>, so a <code>String</code> should be parsed for the field value.</li><li>The <code>rate</code> field has a <code>null</code> JSON value, so the default <code>@choosetype</code> recognizes it should be &quot;lifted&quot; to <code>Missing</code>, which then uses a predefined <code>lift</code> definition for <code>Missing</code>.</li><li>The <code>type</code> field is a <code>Symbol</code>, and has a fieldtag <code>json=(name=&quot;franken_type&quot;,)</code> which means the JSON key <code>franken_type</code> will be used to set the field value instead of the default <code>type</code> field name. A default <code>lift</code> definition for <code>Symbol</code> is used to convert the JSON string value to a <code>Symbol</code>.</li><li>The <code>notsure</code> field is of type <code>Any</code>, so the default object type <code>JSON.Object{String, Any}</code> is used to materialize the JSON value.</li><li>The <code>monster</code> field is a polymorphic type, and the JSON value has a <code>monster_type</code> key that determines which concrete type to use. The <code>@choosetype</code> macro is used to define the logic for choosing the concrete type based on the JSON input. Note that teh <code>x</code> in <code>@choosetype</code> is a <code>LazyValue</code>, so we materialize via <code>x.monster_type[]</code> in order to compare with the string <code>&quot;vampire&quot;</code>.</li><li>The <code>percent</code> field is a custom type <code>Percent</code> and the <code>JSON.lift</code> defines how to construct a <code>Percent</code> from the JSON value, which is a <code>Float64</code> in this case.</li><li>The <code>birthdate</code> field uses a custom date format for parsing, specified in the JSON input.</li><li>The <code>percentages</code> field is a dictionary with keys of type <code>Percent</code>, which is a custom type. The <code>liftkey</code> function is defined to convert the JSON string keys to <code>Percent</code> types (parses the Float64 manually)</li><li>The <code>json_properties</code> field has a type of <code>JSONText</code>, which means the raw JSON will be preserved as a String of the <code>JSONText</code> type.</li><li>The <code>matrix</code> field is a <code>Matrix{Float64}</code>, so the JSON input array-of-arrays are materialized as such.</li><li>The <code>extra_key</code> field is not defined in the <code>FrankenStruct</code> type, so it is ignored and skipped over.</li></ul><p>NOTE: Why use <code>JSON.Object{String, Any}</code> as the default object type? It provides several benefits:</p><ul><li>Behaves as a drop-in replacement for <code>Dict{String, Any}</code>, so no loss of functionality</li><li>Performance! It&#39;s internal representation means memory savings and faster construction for small objects typical in JSON (vs <code>Dict</code>)</li><li>Insertion order is preserved, so the order of keys in the JSON input is preserved in <code>JSON.Object</code></li><li>Convenient <code>getproperty</code> (i.e. <code>obj.key</code>) syntax is supported, even for <code>Object{String,Any}</code> key types (again ideal/specialized for JSON usage)</li></ul><p><code>JSON.Object</code> internal representation uses a linked list, thus key lookups are linear time (O(n)). For <em>large</em> JSON objects, (hundreds or thousands of keys), consider using a <code>Dict{String, Any}</code> instead, like <code>JSON.parse(json; dicttype=Dict{String, Any})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/parse.jl#L1-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.print" href="#JSON.print"><code>JSON.print</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.json(x) -&gt; String
JSON.json(io, x)
JSON.json(file_name, x)</code></pre><p>Serialize <code>x</code> to JSON format. The 1st method takes just the object and returns a <code>String</code>. In the 2nd method, <code>io</code> is an <code>IO</code> object, and the JSON output will be written to it. For the 3rd method, <code>file_name</code> is a <code>String</code>, a file will be opened and the JSON output will be written to it.</p><p>All methods accept the following keyword arguments:</p><ul><li><p><code>omit_null::Union{Bool, Nothing}=nothing</code>: Controls whether struct fields that are undefined or are <code>nothing</code> are included in the JSON output. If <code>true</code>, only non-null fields are written. If <code>false</code>, all fields are included regardless of being undefined or <code>nothing</code>. If <code>nothing</code>, the behavior is determined by <code>JSON.omit_null(::Type{T})</code>, which is <code>false</code> by default.</p></li><li><p><code>omit_empty::Union{Bool, Nothing}=nothing</code>: Controls whether struct fields that are empty are included in the JSON output. If <code>true</code>, empty fields are excluded. If <code>false</code>, empty fields are included. If <code>nothing</code>, the behavior is determined by <code>JSON.omit_empty(::Type{T})</code>.</p></li><li><p><code>allownan::Bool=false</code>: If <code>true</code>, allow <code>Inf</code>, <code>-Inf</code>, and <code>NaN</code> in the output. If <code>false</code>, throw an error if <code>Inf</code>, <code>-Inf</code>, or <code>NaN</code> is encountered.</p></li><li><p><code>jsonlines::Bool=false</code>: If <code>true</code>, input must be array-like and the output will be written in the JSON Lines format, where each element of the array is written on a separate line (i.e. separated by a single newline character `</p></li></ul><p><code>).   If</code>false`, the output will be written in the standard JSON format.</p><ul><li><p><code>pretty::Union{Integer,Bool}=false</code>: Controls pretty printing of the JSON output. If <code>true</code>, the output will be pretty-printed with 2 spaces of indentation. If an integer, it will be used as the number of spaces of indentation. If <code>false</code> or <code>0</code>, the output will be compact. Note: Pretty printing is not supported when <code>jsonlines=true</code>.</p></li><li><p><code>inline_limit::Int=0</code>: For arrays shorter than this limit, pretty printing will be disabled (indentation set to 0).</p></li><li><p><code>ninf::String=&quot;-Infinity&quot;</code>: Custom string representation for negative infinity.</p></li><li><p><code>inf::String=&quot;Infinity&quot;</code>: Custom string representation for positive infinity.</p></li><li><p><code>nan::String=&quot;NaN&quot;</code>: Custom string representation for NaN.</p></li><li><p><code>float_style::Symbol=:shortest</code>: Controls how floating-point numbers are formatted. Options are:</p><ul><li><code>:shortest</code>: Use the shortest representation that preserves the value</li><li><code>:fixed</code>: Use fixed-point notation</li><li><code>:exp</code>: Use exponential notation</li></ul></li><li><p><code>float_precision::Int=1</code>: Number of decimal places to use when <code>float_style</code> is <code>:fixed</code> or <code>:exp</code>.</p></li><li><p><code>bufsize::Int=2^22</code>: Buffer size in bytes for IO operations. When writing to IO, the buffer will be flushed  to the IO stream once it reaches this size. This helps control memory usage during large write operations. Default is 4MB (2^22 bytes). This parameter is ignored when returning a String.</p></li><li><p><code>style::JSONStyle=JSONWriteStyle()</code>: Custom style object that controls serialization behavior. This allows customizing   certain aspects of serialization, like defining a custom <code>lower</code> method for a non-owned type. Like <code>struct MyStyle &lt;: JSONStyle end</code>,   <code>JSON.lower(x::Rational) = (num=x.num, den=x.den)</code>, then calling <code>JSON.json(1//3; style=MyStyle())</code> will output   <code>{&quot;num&quot;: 1, &quot;den&quot;: 3}</code>.</p></li></ul><p>By default, <code>x</code> must be a JSON-serializable object. Supported types include:</p><ul><li><code>AbstractString</code> =&gt; JSON string: types must support the <code>AbstractString</code> interface, specifically with support for <code>ncodeunits</code> and <code>codeunit(x, i)</code>.</li><li><code>Bool</code> =&gt; JSON boolean: must be <code>true</code> or <code>false</code></li><li><code>Nothing</code> =&gt; JSON null: must be the <code>nothing</code> singleton value</li><li><code>Number</code> =&gt; JSON number: <code>Integer</code> subtypes or <code>Union{Float16, Float32, Float64}</code> have default implementations for other <code>Number</code> types, <a href="#JSON.tostring-Tuple{Any}"><code>JSON.tostring</code></a> is first called to convert the value to a <code>String</code> before being written directly to JSON output</li><li><code>AbstractArray</code>/<code>Tuple</code>/<code>AbstractSet</code> =&gt; JSON array: objects for which <code>JSON.arraylike</code> returns <code>true</code>  are output as JSON arrays. <code>arraylike</code> is defined by default for <code>AbstractArray</code>, <code>AbstractSet</code>, <code>Tuple</code>, and <code>Base.Generator</code>. For other types that define, they must also properly implement <code>StructUtils.applyeach</code> to iterate over the index =&gt; elements pairs. Note that arrays with dimensionality &gt; 1 are written as nested arrays, with <code>N</code> nestings for <code>N</code> dimensions, and the 1st dimension is always the innermost nested JSON array (column-major order).</li><li><code>AbstractDict</code>/<code>NamedTuple</code>/structs =&gt; JSON object: if a value doesn&#39;t fall into any of the above categories, it is output as a JSON object. <code>StructUtils.applyeach</code> is called, which has appropriate implementations for <code>AbstractDict</code>, <code>NamedTuple</code>, and structs, where field names =&gt; values are iterated over. Field names can be output with an alternative name via field tag overload, like <code>field::Type &amp;(json=(name=&quot;alternative_name&quot;,),)</code></li></ul><p>If an object is not JSON-serializable, an override for <code>JSON.lower</code> can be defined to convert it to a JSON-serializable object. Some default <code>lower</code> defintions are defined in JSON itself, for example:</p><ul><li><code>StructUtils.lower(::Missing) = nothing</code></li><li><code>StructUtils.lower(x::Symbol) = String(x)</code></li><li><code>StructUtils.lower(x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType}) = string(x)</code></li><li><code>StructUtils.lower(x::Regex) = x.pattern</code></li></ul><p>These allow common Base/stdlib types to be serialized in an expected format.</p><p>Circular references are tracked automatically and cycles are broken by writing <code>null</code> for any children references.</p><p>For pre-formatted JSON data as a String, use <code>JSONText(json)</code> to write the string out as-is.</p><p>For <code>AbstractDict</code> objects with non-string keys, <code>StructUtils.lowerkey</code> will be called before serializing. This allows aggregate or other types of dict keys to be converted to an appropriate string representation. See <code>StructUtils.liftkey</code> for the reverse operation, which is called when parsing JSON data back into a dict type.</p><p><em>NOTE</em>: <code>JSON.json</code> should <em>not</em> be overloaded directly by custom types as this isn&#39;t robust for various output options (IO, String, etc.) nor recursive situations. Types should define an appropriate <code>JSON.lower</code> definition instead.</p><p>Examples:</p><pre><code class="language-julia hljs">using Dates

abstract type AbstractMonster end

struct Dracula &lt;: AbstractMonster
    num_victims::Int
end

struct Werewolf &lt;: AbstractMonster
    witching_hour::DateTime
end

struct Percent &lt;: Number
    value::Float64
end

JSON.lower(x::Percent) = x.value
StructUtils.lowerkey(x::Percent) = string(x.value)

@noarg mutable struct FrankenStruct
    id::Int
    name::String # no default to show serialization of an undefined field
    address::Union{Nothing, String} = nothing
    rate::Union{Missing, Float64} = missing
    type::Symbol = :a &amp;(json=(name=&quot;franken_type&quot;,),)
    notsure::Any = JSON.Object(&quot;key&quot; =&gt; &quot;value&quot;)
    monster::AbstractMonster = Dracula(10) &amp;(json=(lower=x -&gt; x isa Dracula ? (monster_type=&quot;vampire&quot;, num_victims=x.num_victims) : (monster_type=&quot;werewolf&quot;, witching_hour=x.witching_hour),),)
    percent::Percent = Percent(0.5)
    birthdate::Date = Date(2025, 1, 1) &amp;(json=(dateformat=&quot;yyyy/mm/dd&quot;,),)
    percentages::Dict{Percent, Int} = Dict{Percent, Int}(Percent(0.0) =&gt; 0, Percent(1.0) =&gt; 1)
    json_properties::JSONText = JSONText(&quot;{&quot;key&quot;: &quot;value&quot;}&quot;)
    matrix::Matrix{Float64} = [1.0 2.0; 3.0 4.0]
    extra_field::Any = nothing &amp;(json=(ignore=true,),)
end

franken = FrankenStruct()
franken.id = 1

json = JSON.json(franken; omit_null=false)
# &quot;{&quot;id&quot;:1,&quot;name&quot;:null,&quot;address&quot;:null,&quot;rate&quot;:null,&quot;franken_type&quot;:&quot;a&quot;,&quot;notsure&quot;:{&quot;key&quot;:&quot;value&quot;},&quot;monster&quot;:{&quot;monster_type&quot;:&quot;vampire&quot;,&quot;num_victims&quot;:10},&quot;percent&quot;:0.5,&quot;birthdate&quot;:&quot;2025/01/01&quot;,&quot;percentages&quot;:{&quot;1.0&quot;:1,&quot;0.0&quot;:0},&quot;json_properties&quot;:{&quot;key&quot;: &quot;value&quot;},&quot;matrix&quot;:[[1.0,3.0],[2.0,4.0]]}&quot;</code></pre><p>A few comments on the JSON produced in the example above:</p><ul><li>The <code>name</code> field was <code>#undef</code>, and thus was serialized as <code>null</code>.</li><li>The <code>address</code> and <code>rate</code> fields were <code>nothing</code> and <code>missing</code>, respectively, and thus were serialized as <code>null</code>.</li><li>The <code>type</code> field has a <code>name</code> field tag, so the JSON key for this field is <code>franken_type</code> instead of <code>type</code>.</li><li>The <code>notsure</code> field is a <code>JSON.Object</code>, so it is serialized as a JSON object.</li><li>The <code>monster</code> field is a <code>AbstractMonster</code>, which is a custom type. It has a <code>lower</code> field tag that specifies how the value of this field specifically (not all AbstractMonster) should be serialized</li><li>The <code>percent</code> field is a <code>Percent</code>, which is a custom type. It has a <code>lower</code> method that specifies how <code>Percent</code> values should be serialized</li><li>The <code>birthdate</code> field has a <code>dateformat</code> field tag, so the value follows the format (<code>yyyy/mm/dd</code>) instead of the default date ISO format (<code>yyyy-mm-dd</code>)</li><li>The <code>percentages</code> field is a <code>Dict{Percent, Int}</code>, which is a custom type. It has a <code>lowerkey</code> method that specifies how <code>Percent</code> keys should be serialized as strings</li><li>The <code>json_properties</code> field is a <code>JSONText</code>, so the JSONText value is serialized as-is</li><li>The <code>matrix</code> field is a <code>Matrix{Float64}</code>, which is a custom type. It is serialized as a JSON array, with the first dimension being the innermost nested JSON array (column-major order)</li><li>The <code>extra_field</code> field has a <code>ignore</code> field tag, so it is skipped when serializing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/write.jl#L214-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.tostring-Tuple{Any}" href="#JSON.tostring-Tuple{Any}"><code>JSON.tostring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON.tostring(x)</code></pre><p>Overloadable function that allows non-<code>Integer</code> <code>Number</code> types to convert themselves to a <code>String</code> that is then used when serializing <code>x</code> to JSON. Note that if the result of <code>tostring</code> is not a valid JSON number, it will be serialized as a JSON string, with double quotes around it.</p><p>An example overload would look something like:</p><pre><code class="language-julia hljs">JSON.tostring(x::MyDecimal) = string(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/write.jl#L661-L674">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.@omit_empty-Tuple{Any}" href="#JSON.@omit_empty-Tuple{Any}"><code>JSON.@omit_empty</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@omit_empty struct T ...
@omit_empty T</code></pre><p>Convenience macro to set <code>omit_empty(::Type{T})</code> to <code>true</code> for the struct <code>T</code>. Can be used in three ways:</p><ol><li>In front of a struct definition: <code>@omit_empty struct T ... end</code></li><li>Applied to an existing struct name: <code>@omit_empty T</code></li><li>Chained with other macros: <code>@omit_empty @other_macro struct T ... end</code></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/write.jl#L105-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON.@omit_null-Tuple{Any}" href="#JSON.@omit_null-Tuple{Any}"><code>JSON.@omit_null</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@omit_null struct T ...
@omit_null T</code></pre><p>Convenience macro to set <code>omit_null(::Type{T})</code> to <code>true</code> for the struct <code>T</code>. Can be used in three ways:</p><ol><li>In front of a struct definition: <code>@omit_null struct T ... end</code></li><li>Applied to an existing struct name: <code>@omit_null T</code></li><li>Chained with other macros: <code>@omit_null @defaults struct T ... end</code></li></ol><p>The macro automatically handles complex macro expansions by walking the expression tree to find struct definitions, making it compatible with macros like <code>StructUtils.@defaults</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Method 1: Struct annotation
@omit_null struct Person
    name::String
    email::Union{Nothing, String}
end

# Method 2: Apply to existing struct
struct User
    id::Int
    profile::Union{Nothing, String}
end
@omit_null User

# Method 3: Chain with @defaults
@omit_null @defaults struct Employee
    name::String = &quot;Anonymous&quot;
    manager::Union{Nothing, String} = nothing
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JSON.jl/blob/706c1c036ac6498725449a95af880c3d0e023f17/src/write.jl#L40-L74">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reading/">« JSON Reading</a><a class="docs-footer-nextpage" href="../writing/">JSON Writing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 2 August 2025 01:02">Saturday 2 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
